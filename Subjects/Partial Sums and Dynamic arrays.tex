\section{Partial Sums \& Dynamic Arrays}
\subsection{Partial Sums (Fenwick Trees)}

A fenwick tree is effectively binary tree consisting of only the right child.
This allows for an in-place data structure to compute the partial sum.
\begin{table}[H]
    \begin{tabular}{c|c|c|c|c}
        & Sum & Update & Space & Create \\
        \hline
        Fenwick Tree & $O(\log n)$ & $O(\log n)$ & In-place & $O(n\log n)$
    \end{tabular}
\end{table}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node/.style={circle, draw, minimum size=0.8cm},
    level distance=1.5cm,
    sibling distance=1.5cm
]

% Array representation
\node at (-1, 2) {Array:};
\foreach \i in {1,...,8} {
    \node[draw, minimum size=0.8cm] at (\i*1.2-1.2, 2) {\i};
}

% Fenwick tree structure showing responsibility ranges
\node at (-1, 0) {Tree:};

% Level 0 (individual elements)
\foreach \i in {1,3,5,7} {
    \node[node, fill=blue!20] (n\i) at (\i*1.2-1.2, 0) {\i};
}

% Level 1 (pairs)
\foreach \i in {2,6} {
    \node[node, fill=green!20] (n\i) at (\i*1.2-1.2, -1.5) {\i};
}

% Level 2 (fours)
\node[node, fill=orange!20] (n4) at (4*1.2-1.2, -3) {4};

% Level 3 (eight)
\node[node, fill=red!20] (n8) at (8*1.2-1.2, -4.5) {8};

% Draw edges showing which elements each node covers
\draw[->] (n2) -- (n1);
\draw[->] (n4) -- (n3);
\draw[->] (n4) -- (n2);
\draw[->] (n6) -- (n5);
\draw[->] (n8) -- (n7);
\draw[->] (n8) -- (n6);
\draw[->] (n8) -- (n4);

% Add labels for ranges
\node[below=0.1cm of n1, font=\small] {[1]};
\node[below=0.1cm of n2, font=\small] {[1,2]};
\node[below=0.1cm of n3, font=\small] {[3]};
\node[below=0.1cm of n4, font=\small] {[1,4]};
\node[below=0.1cm of n5, font=\small] {[5]};
\node[below=0.1cm of n6, font=\small] {[5,6]};
\node[below=0.1cm of n7, font=\small] {[7]};
\node[below=0.1cm of n8, font=\small] {[1,8]};

\end{tikzpicture}
\end{figure}
\subsection{Example}
here is an example on how to calculate a fenwick tree.
\begin{verbatim}
Index:  1   2   3   4   5   6   7   8
Value:  3   2   5   1   4   6   2   3

Index:  1   2   3   4   5   6   7   8
BIT:    3   2   5   1   4   6   2   3

Index:  1   2   3   4   5   6   7   8
BIT:    3   2   5   1   4   6   2   3

Index:  1   2   3   4   5   6   7   8
BIT:    3   5   5   1   4   6   2   3

Index:  1   2   3   4   5   6   7   8
BIT:    3   5   5   1   4   6   2   3

Index:  1   2   3   4   5   6   7   8
BIT:    3   5   5  11   4   6   2   3

Index:  1   2   3   4   5   6   7   8
BIT:    3   5   5  11   4   6   2   3

Index:  1   2   3   4   5   6   7   8
BIT:    3   5   5  11   4  10   2   3

Index:  1   2   3   4   5   6   7   8
BIT:    3   5   5  11   4  10   2   3

Index:  1   2   3   4   5   6   7   8
BIT:    3   5   5  11   4  10   2  26

Final Fenwick Tree:
Index:  1   2   3   4   5   6   7   8
BIT:    3   5   5  11   4  10   2  26
Range: [1][1,2][3][1,4][5][5,6][7][1,8]
\end{verbatim}

\section{Dynamic Arrays}
\subsection{Rotated Array}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/1-level-rotated-array.png}
    \caption{1 level rotated array}
\end{figure}
\textbf{Key idea:} Store offset to mark the start of the array.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/2-level-rotated-array.png}
    \caption{2 level rotated array}
\end{figure}
\textbf{Key idea:} Split into $\sqrt{n}$ rotated buckets of size $\sqrt{n}$. When inserting/deleting, rebuild one bucket in $O(\sqrt{n})$ time, then propagate overflow/underflow.

\begin{table}[H]
    \centering
    \begin{tabular}{c|c|c|c|c}
        Data Structure & Access & Insert & Delete & space \\
        \hline
        1 level rotated array & $\BigO(1)$ & $\BigO(\sqrt{n})$ & $\BigO(\sqrt{n})$ & $\BigO(n)$ \\
         \hline
        2 level rotated array & $\BigO(1)$ & $\BigO(n^\varepsilon)$ & $\BigO(n^\varepsilon$ & $\BigO(n)$ \\
    \end{tabular}
\end{table}
In a $k$-level rotated array, $\varepsilon = \frac{1}{k}$ determines that you
partition $n$ elements into $\sqrt[k]{n}$ buckets of size $\sqrt[k]{n}$ each,
giving $O(n^{1/k}) = O(n^{\varepsilon})$ time for
\textsc{Insert}/\textsc{Delete} operations.

